from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from datetime import datetime

from app.core.database import get_db
from app.models.domain import Post, ContentStatus, ConnectedAccount
from app.schemas.posts.post import PostRead, PostUpdate
from app.schemas.common.base import StandardResponse
from app.core.logging import logger
from app.services.publishers.linkedin import LinkedInPublisher
from app.core.config import get_settings

router = APIRouter()
settings = get_settings()

@router.get("/", response_model=StandardResponse[List[PostRead]])
def list_posts(
    project_id: int = None, 
    status: str = None, 
    limit: int = 10, 
    db: Session = Depends(get_db)
):
    query = db.query(Post)
    
    if project_id:
        query = query.filter(Post.project_id == project_id)
    if status:
        query = query.filter(Post.status == status)
        
    posts = query.order_by(Post.created_at.desc()).limit(limit).all()
    return StandardResponse(data=posts)

from fastapi.responses import StreamingResponse
import io
import json

@router.get("/{post_id}/export")
def export_post(
    post_id: int,
    format: str = "md", # md, txt, json
    db: Session = Depends(get_db)
):
    """
    Exporta el contenido del post en formato TXT, Markdown o JSON.
    Útil para publicación manual cuando las integraciones están desactivadas.
    """
    db_post = db.query(Post).filter(Post.id == post_id).first()
    if not db_post:
        raise HTTPException(status_code=404, detail="Post not found")
        
    if format == "json":
        data = {
            "id": db_post.id,
            "title": db_post.title,
            "content": db_post.content_text,
            "cta": db_post.cta,
            "hashtags": db_post.hashtags,
            "identity": db_post.identity_used,
            "manual_content": db_post.manual_content,
            "status": db_post.status,
            "exported_at": datetime.utcnow().isoformat()
        }
        content = json.dumps(data, indent=2)
        media_type = "application/json"
    else:
        # Construir contenido texto/md
        content = f"# {db_post.title or 'Untitled'}\n\n"
        content += f"{db_post.content_text}\n\n"
        
        if db_post.cta:
            content += f"**CTA:** {db_post.cta}\n\n"
            
        if db_post.hashtags:
            content += f"**Hashtags:** {db_post.hashtags}\n"
            
        content += f"\n---\nGenerated by Identity: {db_post.identity_used}"
            
        media_type = "text/markdown" if format == "md" else "text/plain"

    filename = f"post_{post_id}.{format}"
    
    return StreamingResponse(
        io.BytesIO(content.encode("utf-8")),
        media_type=media_type,
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )

@router.get("/{post_id}/share")
def share_post(
    post_id: int,
    db: Session = Depends(get_db)
):
    """
    Genera un snapshot compartible del post (útil para previsualización externa).
    """
    db_post = db.query(Post).filter(Post.id == post_id).first()
    if not db_post:
        raise HTTPException(status_code=404, detail="Post not found")
        
    return {
        "content": db_post.manual_content,
        "identity": db_post.identity_used,
        "timestamp": datetime.utcnow().isoformat(),
        "hash": abs(hash(f"{post_id}{datetime.utcnow()}")) # Simple hash positive
    }

@router.put("/{post_id}", response_model=StandardResponse[PostRead])
def update_post(
    post_id: int,
    post_update: PostUpdate,
    db: Session = Depends(get_db)
):
    """
    Actualiza un post existente.
    - Permite editar contenido solo si NO está APPROVED.
    - Para aprobar (status=APPROVED), DEBE tener fecha de programación (scheduled_for).
    """
    db_post = db.query(Post).filter(Post.id == post_id).first()
    if not db_post:
        raise HTTPException(status_code=404, detail="Post not found")

    # Detectar si hay cambios de contenido
    content_fields = ["title", "content_text", "hashtags", "cta"]
    is_content_edit = any(
        getattr(post_update, field) is not None 
        for field in content_fields
    )
    
    current_status = db_post.status
    new_status = post_update.status or current_status
    
    # Regla: Estados finales bloquean edición de contenido
    readonly_statuses = [ContentStatus.APPROVED, ContentStatus.SCHEDULED_AUTO, ContentStatus.PUBLISHED_AUTO, ContentStatus.PUBLISHED]
    if current_status in readonly_statuses and is_content_edit:
        if new_status in readonly_statuses:
             logger.warning(f"Intento de editar post en estado {current_status} sin revertir")
             raise HTTPException(
                status_code=400, 
                detail=f"No se puede editar contenido en estado {current_status}. Revierta a DRAFT primero."
            )

    # Regla: Para programar auto, se requiere fecha
    if new_status in [ContentStatus.APPROVED, ContentStatus.SCHEDULED_AUTO]:
        final_scheduled_for = post_update.scheduled_for or db_post.scheduled_for
        if not final_scheduled_for:
            logger.warning(f"Intento de programar post {post_id} sin fecha")
            raise HTTPException(
                status_code=400, 
                detail="El post debe tener fecha de publicación para ser programado automáticamente."
            )

    # Aplicar cambios
    update_data = post_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_post, field, value)

    try:
        db.commit()
        db.refresh(db_post)
        logger.info(f"Post {post_id} actualizado. Status: {db_post.status}")
        return StandardResponse(data=db_post)
    except Exception as e:
        db.rollback()
        logger.error(f"Error actualizando post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error interno al actualizar post")

@router.post("/{post_id}/publish", response_model=StandardResponse[PostRead])
async def publish_post_now(
    post_id: int,
    db: Session = Depends(get_db)
):
    """
    Publica inmediatamente un post aprobado.
    Si no hay credenciales o integraciones activas, sugiere publicación manual.
    """
    db_post = db.query(Post).filter(Post.id == post_id).first()
    if not db_post:
        raise HTTPException(status_code=404, detail="Post not found")
        
    if db_post.status not in [ContentStatus.APPROVED, ContentStatus.SCHEDULED_AUTO, ContentStatus.READY_MANUAL]:
        raise HTTPException(status_code=400, detail="Solo se pueden publicar posts en estado APPROVED, SCHEDULED_AUTO o READY_MANUAL")
        
    # 1. Feature Flag Check
    if not settings.FEATURE_LINKEDIN_ENABLED:
         raise HTTPException(
             status_code=400, 
             detail="Publicación automática desactivada (Feature Flag). Por favor, copia el contenido y publica manualmente."
         )

    # 2. Account Check
    account = db.query(ConnectedAccount).filter(ConnectedAccount.project_id == db_post.project_id).first()
    
    if not account or not account.access_token_encrypted:
        raise HTTPException(
             status_code=400, 
             detail="No hay cuenta de LinkedIn conectada. Por favor, conecta una cuenta o publica manualmente."
         )
        
    # 3. Publish Logic
    publisher = LinkedInPublisher()
    try:
        logger.info(f"Publishing Post {post_id} to {account.provider_name}...")
        result = await publisher.publish(db_post, account)
        
        # Actualizar post
        db_post.status = ContentStatus.PUBLISHED_AUTO
        db_post.published_at = datetime.utcnow()
        # db_post.external_id = result.get("external_id") # Si tuviera ese campo en modelo
        
        db.commit()
        db.refresh(db_post)
        return StandardResponse(data=db_post, message="Post publicado exitosamente")
        
    except Exception as e:
        logger.error(f"Error publicando post {post_id}: {e}")
        # Retornamos error controlado para que el frontend muestre el mensaje
        db_post.status = ContentStatus.FAILED_AUTO_MANUAL_AVAILABLE
        db.commit()
        
        raise HTTPException(
            status_code=400, 
            detail=f"Error al publicar en LinkedIn: {str(e)}. Intenta manualmente."
        )
